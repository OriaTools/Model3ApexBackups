#region Using declarations
using System;
using System.ComponentModel.DataAnnotations;
using NinjaTrader.Cbi;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.NinjaScript.Indicators;
using NinjaTrader.Core;
#endregion

// ==================================================================
// M3_Eval — EVAL-OPTIMIZED CLEAN VERSION (Apex 100K) with ATM (SAFE)
// ------------------------------------------------------------------
// • ATM handles: partials + SL + TP + BE + trailing
// • Strategy handles: entries + session/risk guards + hard flatten + time stop
// • IMPORTANT: No SetStopLoss/SetProfitTarget in code (ATM owns exits)
// ==================================================================

namespace NinjaTrader.NinjaScript.Strategies
{
    public class M3_Eval : Strategy
    {
        private EMA fastEMA;
        private EMA slowEMA;
        private RSI rsi;

        private DateTime currentDay = DateTime.MinValue;
        private double dayStartEquity = 0;
        private double dayHighWatermark = 0;
        private bool profitLockedToday = false;

        private int tradesToday = 0;

        // --- ATM & State ---
        private string activeAtmId = string.Empty;
        private bool atmPending = false;

        // --- Warm-up / gating ---
        private DateTime realtimeStart = DateTime.MinValue;
        private bool entryLocked = false;
        private DateTime entrySubmitTime = DateTime.MinValue;
        private DateTime lastEntryTime = DateTime.MinValue;

        // --- Daily guards ---
        private bool forcedFlatToday = false;

        // ---------------- PARAMETERS ----------------
        [NinjaScriptProperty]
        [Display(Name = "Max Trades Per Day", GroupName = "Risk", Order = 1)]
        public int MaxTradesPerDay { get; set; } = 80;

        [NinjaScriptProperty]
        [Display(Name = "Session Start (HHmmss)", GroupName = "Session", Order = 2)]
        public int SessionStart { get; set; } = 93000;

        [NinjaScriptProperty]
        [Display(Name = "Session End (HHmmss)", GroupName = "Session", Order = 3)]
        public int SessionEnd { get; set; } = 170000;

        [NinjaScriptProperty]
        [Display(Name = "Hard Flatten Time (HHmmss)", GroupName = "Session", Order = 4)]
        public int HardFlattenTime { get; set; } = 165900; // 16:59:00

        [NinjaScriptProperty]
        [Display(Name = "Max Trailing Drawdown ($)", GroupName = "Risk", Order = 5)]
        public double MaxTrailingDrawdown { get; set; } = 2500;

        [NinjaScriptProperty]
        [Display(Name = "Max Daily Profit Cap ($)", GroupName = "Risk", Order = 6)]
        public double MaxDailyProfitCap { get; set; } = 1200;

        [NinjaScriptProperty]
        [Display(Name = "ATM Template Name", GroupName = "ATM", Order = 9)]
        public string AtmTemplateName { get; set; } = "M3_ATM";

        // --- Timing helpers ---
        private DateTime Now() => (State == State.Realtime ? Core.Globals.Now : Time[0]);

        protected override void OnStateChange()
        {
            if (State == State.SetDefaults)
            {
                Name = "M3_Eval";
                Calculate = Calculate.OnEachTick;

                EntriesPerDirection = 1;
                EntryHandling = EntryHandling.AllEntries;
                BarsRequiredToTrade = 50;

                StartBehavior = StartBehavior.WaitUntilFlat;

                IsExitOnSessionCloseStrategy = true;
                ExitOnSessionCloseSeconds = 30;

                RealtimeErrorHandling = RealtimeErrorHandling.IgnoreAllErrors;
                ConnectionLossHandling = ConnectionLossHandling.KeepRunning;

                TraceOrders = true;
            }
            else if (State == State.DataLoaded)
            {
                fastEMA = EMA(9);
                slowEMA = EMA(21);
                rsi = RSI(14, 3);

                AddChartIndicator(fastEMA);
                AddChartIndicator(slowEMA);
                AddChartIndicator(rsi);
            }
        }

        protected override void OnBarUpdate()
        {
            // ATM works best realtime only
            if (State != State.Realtime)
                return;

            DateTime now = Core.Globals.Now;

            // ----- ATM WARM-UP -----
            if (realtimeStart == DateTime.MinValue)
            {
                realtimeStart = now;
                return;
            }
            if ((now - realtimeStart).TotalSeconds < 5)
                return;

            if (CurrentBar < BarsRequiredToTrade)
                return;

            // ----- Daily reset -----
            if (currentDay != Time[0].Date)
                ResetDailyState(GetEquitySafe());

            int t = ToTime(Time[0]);

            // ----- Hard flatten -----
            if (!forcedFlatToday && t >= HardFlattenTime)
            {
                forcedFlatToday = true;
                SafeFlatten();
                return;
            }
            if (forcedFlatToday) return;

            // ----- RTH guard -----
            if (t < SessionStart || t > SessionEnd)
            {
                SafeFlatten();
                return;
            }

            // ----- Risk halt -----
            if (IsTradingHalted(GetEquitySafe()))
            {
                SafeFlatten();
                return;
            }

            // ----- ATM active guard -----
            if (!string.IsNullOrEmpty(activeAtmId))
            {
                if (GetAtmStrategyMarketPosition(activeAtmId) == MarketPosition.Flat)
                    activeAtmId = string.Empty;
                else
                    return;
            }

            if (atmPending) return;

            // ----- Signal -----
            double volSma = SMA(Volume, 20)[0];
            if (volSma <= 0) return;

            double mood = fastEMA[0] - slowEMA[0];
            double volSpike = Volume[0] / volSma;

            bool goLong = mood > 0.05 && rsi[0] > 45 && volSpike > 1.2;
            bool goShort = mood < -0.05 && rsi[0] < 55 && volSpike > 1.2;

            // ----- Entry gating -----
            if (tradesToday >= MaxTradesPerDay) return;
            if (entryLocked) return;

            // (optional) small cooldown so it doesn’t spam ATM on noisy ticks
            if (lastEntryTime != DateTime.MinValue && (now - lastEntryTime).TotalSeconds < 10)
                return;

            if (Position.MarketPosition == MarketPosition.Flat && (goLong || goShort))
            {
                entryLocked = true;
                entrySubmitTime = now;
                lastEntryTime = now;

                atmPending = true;

                string ocoId = "M3OCO_" + now.Ticks;
                string atmStrategyId = "M3ATM_" + now.Ticks;

                AtmStrategyCreate(
                    goLong ? OrderAction.Buy : OrderAction.SellShort,
                    OrderType.Market,
                    0, 0,
                    TimeInForce.Day,
                    ocoId,
                    AtmTemplateName,
                    atmStrategyId,
                    (errorCode, callbackId) =>
                    {
                        atmPending = false;

                        if (errorCode == ErrorCode.NoError)
                        {
                            activeAtmId = callbackId;
                            tradesToday++;
                            Print($"ATM START OK | tradesToday={tradesToday} | atmId={activeAtmId}");
                        }
                        else
                        {
                            Print($"ATM START FAIL | error={errorCode}");
                        }

                        // unlock either way after callback
                        entryLocked = false;
                        entrySubmitTime = DateTime.MinValue;
                    });
            }

            // ----- failsafe unlock if callback never comes back -----
            if (entryLocked &&
                entrySubmitTime != DateTime.MinValue &&
                (now - entrySubmitTime).TotalSeconds > 15)
            {
                entryLocked = false;
                entrySubmitTime = DateTime.MinValue;
                atmPending = false;
            }

            // ----- Time stop safety (ATM close) -----
            if (!string.IsNullOrEmpty(activeAtmId))
            {
                // If ATM has a position open for >180s, close it.
                // We don’t have perfect entry-fill time without extra ATM querying,
                // so we use lastEntryTime as a practical safety timer.
                if ((now - lastEntryTime).TotalSeconds > 180)
                {
                    SafeFlatten();
                    return;
                }
            }
        }

        private void ResetDailyState(double equity)
        {
            currentDay = Time[0].Date;
            dayStartEquity = equity;
            dayHighWatermark = equity;

            profitLockedToday = false;
            tradesToday = 0;

            forcedFlatToday = false;

            activeAtmId = string.Empty;
            atmPending = false;

            entryLocked = false;
            entrySubmitTime = DateTime.MinValue;
            lastEntryTime = DateTime.MinValue;
        }

        private bool IsTradingHalted(double equity)
        {
            if (equity > dayHighWatermark + 50)
                profitLockedToday = true;

            if (equity > dayHighWatermark)
                dayHighWatermark = equity;

            double dayPnL = equity - dayStartEquity;
            double trailDD = equity - dayHighWatermark;

            return trailDD <= -MaxTrailingDrawdown || dayPnL >= MaxDailyProfitCap;
        }

        private double GetEquitySafe()
        {
            double realized = SystemPerformance.AllTrades.TradesPerformance.Currency.CumProfit;
            double unreal = Position.MarketPosition != MarketPosition.Flat
                ? Position.GetUnrealizedProfitLoss(PerformanceUnit.Currency)
                : 0;

            return 100000 + realized + unreal;
        }

        private void SafeFlatten()
        {
            if (string.IsNullOrEmpty(activeAtmId)) return;
            try { AtmStrategyClose(activeAtmId); } catch { }
            activeAtmId = string.Empty;
        }
    }
}

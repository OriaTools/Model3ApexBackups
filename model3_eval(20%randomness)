#region Using declarations
using System;
using System.ComponentModel.DataAnnotations;
using NinjaTrader.Cbi;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.NinjaScript.Indicators;
#endregion

// =======================================================
//  M3_Eval — APEX EVAL EDITION (B)
//  • Original M3 signal engine (mood + RSI + volume) — NO randomness
//  • Fixed contracts (BaseContracts) for consistency
//  • Daily loss + daily profit cap + max trades per day
//  • Optional VIX crash brake via ^VIX 1m secondary series
//  • Time window + time stop
// =======================================================

namespace NinjaTrader.NinjaScript.Strategies
{
    public class M3_Eval : Strategy
    {
        // -----------------------------
        // INDICATORS
        // -----------------------------
        private EMA fastEMA;
        private EMA slowEMA;
        private RSI rsi;

        // -----------------------------
        // CRASH BRAKE / VIX
        // -----------------------------
        private double vixLast = 0;
        private bool   vixTriggered = false;

        // -----------------------------
        // USER PARAMETERS – CRASH BRAKE
        // -----------------------------
        [NinjaScriptProperty]
        [Display(Name = "Use VIX Crash Brake", GroupName = "Crash Brake", Order = 0)]
        public bool UseVixCrashBrake { get; set; } = false;

        [NinjaScriptProperty]
        [Display(Name = "VIX Panic Threshold", GroupName = "Crash Brake", Order = 1)]
        public double VixPanicThreshold { get; set; } = 28.0;

        // -----------------------------
        // USER PARAMETERS – ORDERS
        // -----------------------------
        [NinjaScriptProperty]
        [Display(Name = "Stop Ticks", GroupName = "Orders", Order = 0)]
        public int StopTicks { get; set; } = 22;

        [NinjaScriptProperty]
        [Display(Name = "Target Ticks", GroupName = "Orders", Order = 1)]
        public int TargetTicks { get; set; } = 40;

        [NinjaScriptProperty]
        [Display(Name = "Time Stop (sec)", GroupName = "Orders", Order = 2)]
        public int TimeStopSeconds { get; set; } = 180;

        // -----------------------------
        // USER PARAMETERS – RISK
        // -----------------------------
        [NinjaScriptProperty]
        [Display(Name = "Account Size ($)", GroupName = "Risk", Order = 0)]
        public double AccountSize { get; set; } = 100000;

        [NinjaScriptProperty]
        [Display(Name = "Max Daily Loss ($)", GroupName = "Risk", Order = 1)]
        public double MaxDailyLoss { get; set; } = 3000;

        [NinjaScriptProperty]
        [Display(Name = "Max Daily Profit ($)", GroupName = "Risk", Order = 2)]
        public double MaxDailyProfit { get; set; } = 1200;

        [NinjaScriptProperty]
        [Display(Name = "Max Trades Per Day", GroupName = "Risk", Order = 3)]
        public int MaxTradesPerDay { get; set; } = 8;

        [NinjaScriptProperty]
        [Display(Name = "Base Contracts", GroupName = "Risk", Order = 4)]
        public int BaseContracts { get; set; } = 8;

        // -----------------------------
        // USER PARAMETERS – SESSION
        // -----------------------------
        [NinjaScriptProperty]
        [Display(Name = "Use Time Window", GroupName = "Session", Order = 0)]
        public bool UseTimeWindow { get; set; } = true;

        [NinjaScriptProperty]
        [Display(Name = "Session Start (HHmmss)", GroupName = "Session", Order = 1)]
        public int SessionStart { get; set; } = 93000;  // 09:30:00

        [NinjaScriptProperty]
        [Display(Name = "Session End (HHmmss)", GroupName = "Session", Order = 2)]
        public int SessionEnd { get; set; } = 160000;  // 16:00:00

        // -----------------------------
        // INTERNAL STATE
        // -----------------------------
        private DateTime currentDay      = Core.Globals.MinDate;
        private double   dayStartEquity  = 0;
        private double   dayMaxEquity    = 0;
        private int      tradesToday     = 0;

        private bool dailyLossHit   = false;
        private bool dailyProfitHit = false;
        private bool tradeLimitHit  = false;

        private DateTime lastEntryTime = Core.Globals.MinDate;

        // One-time prints
        private bool printedDailyLoss   = false;
        private bool printedDailyProfit = false;
        private bool printedTradeLimit  = false;
        private bool printedVixBrake    = false;

        // =======================================================
        //  STATE CHANGE
        // =======================================================
        protected override void OnStateChange()
        {
            if (State == State.SetDefaults)
            {
                Name = "M3_Eval";
                Description = "Model 3 Eval Edition — original signal engine, fixed size, eval-safe guards.";

                Calculate = Calculate.OnEachTick;
                EntriesPerDirection = 1;
                EntryHandling = EntryHandling.AllEntries;

                IsExitOnSessionCloseStrategy = false;
                ExitOnSessionCloseSeconds = 0;
                TimeInForce = TimeInForce.Day;

                RealtimeErrorHandling = RealtimeErrorHandling.IgnoreAllErrors;
                ConnectionLossHandling = ConnectionLossHandling.KeepRunning;
                TraceOrders = true;
            }
            else if (State == State.Configure)
            {
                // Secondary series for VIX crash brake (if data is available)
                AddDataSeries("^VIX", BarsPeriodType.Minute, 1, MarketDataType.Last);
            }
            else if (State == State.DataLoaded)
            {
                fastEMA = EMA(9);
                slowEMA = EMA(21);
                rsi     = RSI(14, 3);

                AddChartIndicator(fastEMA);
                AddChartIndicator(slowEMA);
                AddChartIndicator(rsi);
            }
        }

        // =======================================================
        //  MAIN BAR LOOP
        // =======================================================
        protected override void OnBarUpdate()
        {
            // Handle VIX series updates
            if (BarsInProgress == 1)
            {
                vixLast = Closes[1][0];
                return;
            }

            // Only trade on primary MNQ series
            if (BarsInProgress != 0)
                return;

            if (CurrentBar < 50)
                return;

            // -------- DAILY RESET --------
            UpdateDailyState();

            // -------- SESSION FILTER --------
            if (UseTimeWindow)
            {
                int t = ToTime(Time[0]);
                if (t < SessionStart || t > SessionEnd)
                    return;
            }

            // -------- VIX CRASH BRAKE --------
            if (UseVixCrashBrake && vixLast > VixPanicThreshold)
            {
                if (!printedVixBrake)
                {
                    Print(string.Format("[M3_Eval] VIX CRASH BRAKE — VIX={0:F2} > {1:F2}. Flatten & halt.",
                        vixLast, VixPanicThreshold));
                    printedVixBrake = true;
                }

                SafeFlatten();
                return;
            }

            // -------- RISK GUARDS --------
            if (IsTradingHaltedForToday())
                return;    // nothing further today

            // ===================================================
            //  ORIGINAL M3 SIGNAL ENGINE (NO RANDOMNESS)
            // ===================================================
            double mood = fastEMA[0] - slowEMA[0];

            double volBase = SMA(Volume, 20)[0];
            if (volBase <= 0)
                return;

            double volSpike = Volume[0] / volBase;

            bool goLong =
                (mood > 0.05) &&
                (rsi[0] > 45) &&
                (volSpike > 1.2);

            bool goShort =
                (mood < -0.05) &&
                (rsi[0] < 55) &&
                (volSpike > 1.2);

            // Only 1 position at a time
            if (Position.MarketPosition == MarketPosition.Flat)
            {
                if (tradesToday >= MaxTradesPerDay)
                    return;

                if (goLong)
                {
                    SetStopLoss("Amelia", CalculationMode.Ticks, StopTicks, false);
                    SetProfitTarget("Amelia", CalculationMode.Ticks, TargetTicks);
                    EnterLong(BaseContracts, "Amelia");
                }
                else if (goShort)
                {
                    SetStopLoss("Amelia", CalculationMode.Ticks, StopTicks, false);
                    SetProfitTarget("Amelia", CalculationMode.Ticks, TargetTicks);
                    EnterShort(BaseContracts, "Amelia");
                }
            }
            else
            {
                // -------- TIME STOP --------
                if (lastEntryTime > Core.Globals.MinDate
                    && (Time[0] - lastEntryTime).TotalSeconds >= TimeStopSeconds)
                {
                    if (Position.MarketPosition == MarketPosition.Long)
                        ExitLong("TimeStop", "Amelia");
                    else if (Position.MarketPosition == MarketPosition.Short)
                        ExitShort("TimeStop", "Amelia");
                }
            }
        }

        // =======================================================
        //  EXECUTION HANDLER – COUNTS TRADES & STORES ENTRY TIME
        // =======================================================
        protected override void OnExecutionUpdate(Execution execution, string executionId, double price, int quantity,
                                                  MarketPosition marketPosition, string orderId, DateTime time)
        {
            if (execution == null || execution.Order == null)
                return;

            if (execution.Order.OrderState != OrderState.Filled)
                return;

            // Count each *filled entry* as one trade
            if (execution.Order.Name == "Amelia" &&
                (execution.Order.OrderAction == OrderAction.Buy ||
                 execution.Order.OrderAction == OrderAction.SellShort))
            {
                tradesToday++;
                lastEntryTime = time;

                Print(string.Format("[M3_Eval] Trade count updated: {0}", tradesToday));
            }

            // Reset lastEntryTime when flat
            if (Position.MarketPosition == MarketPosition.Flat)
                lastEntryTime = Core.Globals.MinDate;
        }

        // =======================================================
        //  DAILY STATE & GUARDS
        // =======================================================

        private void UpdateDailyState()
        {
            DateTime barDate = Times[0][0].Date;

            if (currentDay != barDate)
            {
                currentDay = barDate;

                double eq = GetEquitySafe();
                dayStartEquity = eq;
                dayMaxEquity   = eq;
                tradesToday    = 0;

                dailyLossHit   = false;
                dailyProfitHit = false;
                tradeLimitHit  = false;

                printedDailyLoss   = false;
                printedDailyProfit = false;
                printedTradeLimit  = false;
                printedVixBrake    = false;

                Print(string.Format("[M3_Eval] DAY RESET {0:yyyy-MM-dd} — StartEquity = {1:F2}",
                    currentDay, dayStartEquity));
            }

            double currentEquity = GetEquitySafe();
            if (currentEquity > dayMaxEquity)
                dayMaxEquity = currentEquity;
        }

        private bool IsTradingHaltedForToday()
        {
            double currentEquity = GetEquitySafe();
            double dayPnL = currentEquity - dayStartEquity;

            // Daily loss
            if (!dailyLossHit && dayPnL <= -Math.Abs(MaxDailyLoss))
            {
                dailyLossHit = true;
                if (!printedDailyLoss)
                {
                    Print(string.Format("[M3_Eval] GUARD: Daily loss hit. PnL={0:F2}, limit={1:F2}.",
                        dayPnL, -Math.Abs(MaxDailyLoss)));
                    printedDailyLoss = true;
                }
            }

            // Daily profit cap
            if (!dailyProfitHit && dayPnL >= Math.Abs(MaxDailyProfit))
            {
                dailyProfitHit = true;
                if (!printedDailyProfit)
                {
                    Print(string.Format("[M3_Eval] GUARD: Daily profit cap reached. PnL={0:F2}, cap={1:F2}.",
                        dayPnL, Math.Abs(MaxDailyProfit)));
                    printedDailyProfit = true;
                }
            }

            // Trade count cap
            if (!tradeLimitHit && tradesToday >= MaxTradesPerDay)
            {
                tradeLimitHit = true;
                if (!printedTradeLimit)
                {
                    Print(string.Format("[M3_Eval] GUARD: Max trades per day reached ({0}/{1}).",
                        tradesToday, MaxTradesPerDay));
                    printedTradeLimit = true;
                }
            }

            return dailyLossHit || dailyProfitHit || tradeLimitHit;
        }

        // =======================================================
        //  EQUITY HELPER: cash + realized + unrealized PnL
        // =======================================================
        private double GetEquitySafe()
        {
            double equity = AccountSize;

            try
            {
                if (Account != null)
                {
                    double cash = Account.Get(AccountItem.CashValue, Currency.UsDollar);
                    if (!double.IsNaN(cash) && !double.IsInfinity(cash) && cash > 0)
                        equity = cash;
                }
            }
            catch
            {
                // fall back to synthetic equity
            }

            double realized = SystemPerformance.AllTrades.TradesPerformance.Currency.CumProfit;
            double unreal   = 0;

            try
            {
                unreal = Position.GetUnrealizedProfitLoss(PerformanceUnit.Currency);
                if (double.IsNaN(unreal) || double.IsInfinity(unreal))
                    unreal = 0;
            }
            catch
            {
                unreal = 0;
            }

            return equity + realized + unreal;
        }

        // =======================================================
        //  SAFE FLATTEN
        // =======================================================
        private void SafeFlatten()
        {
            try { ExitLong("Flat", "Amelia"); }  catch { }
            try { ExitShort("Flat", "Amelia"); } catch { }
        }
    }
}


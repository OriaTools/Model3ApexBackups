#region Using declarations
using System;
using System.ComponentModel.DataAnnotations;
using NinjaTrader.Cbi;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.NinjaScript.Indicators;
#endregion

// =======================================================
//  M3_Fund — FUNDED EDITION (A)
//  • Original M3 signal engine (NO randomness)
//  • Global trailing drawdown (includes unrealized PnL)
//  • ATR-based dynamic stops/targets with floors
//  • Max trades per day
//  • Optional VIX crash brake via ^VIX 1m secondary series
//  • Time window + time stop
// =======================================================

namespace NinjaTrader.NinjaScript.Strategies
{
    public class M3_Fund : Strategy
    {
        // -----------------------------
        // INDICATORS
        // -----------------------------
        private EMA fastEMA;
        private EMA slowEMA;
        private RSI rsi;
        private ATR atr;

        // -----------------------------
        // CRASH BRAKE / VIX
        // -----------------------------
        private double vixLast = 0;
        private bool   vixTriggered = false;

        [NinjaScriptProperty]
        [Display(Name = "Use VIX Crash Brake", GroupName = "Crash Brake", Order = 0)]
        public bool UseVixCrashBrake { get; set; } = true;

        [NinjaScriptProperty]
        [Display(Name = "VIX Panic Threshold", GroupName = "Crash Brake", Order = 1)]
        public double VixPanicThreshold { get; set; } = 28.0;

        // -----------------------------
        // USER PARAMETERS – ORDERS
        // -----------------------------
        [NinjaScriptProperty]
        [Display(Name = "Use ATR for Stops/Targets", GroupName = "Orders", Order = 0)]
        public bool UseATR { get; set; } = true;

        [NinjaScriptProperty]
        [Display(Name = "Stop ATR Multiplier", GroupName = "Orders", Order = 1)]
        public double StopATRMultiplier { get; set; } = 1.5;

        [NinjaScriptProperty]
        [Display(Name = "Target ATR Multiplier", GroupName = "Orders", Order = 2)]
        public double TargetATRMultiplier { get; set; } = 2.5;

        [NinjaScriptProperty]
        [Display(Name = "Min Stop Ticks", GroupName = "Orders", Order = 3)]
        public int MinStopTicks { get; set; } = 10;

        [NinjaScriptProperty]
        [Display(Name = "Min Target Ticks", GroupName = "Orders", Order = 4)]
        public int MinTargetTicks { get; set; } = 20;

        [NinjaScriptProperty]
        [Display(Name = "Time Stop (sec)", GroupName = "Orders", Order = 5)]
        public int TimeStopSeconds { get; set; } = 180;

        // -----------------------------
        // USER PARAMETERS – RISK
        // -----------------------------
        [NinjaScriptProperty]
        [Display(Name = "Account Size ($)", GroupName = "Risk", Order = 0)]
        public double AccountSize { get; set; } = 100000;

        [NinjaScriptProperty]
        [Display(Name = "Trailing Drawdown Limit ($)", GroupName = "Risk", Order = 1)]
        public double TrailingDrawdownLimit { get; set; } = 3000;

        [NinjaScriptProperty]
        [Display(Name = "Max Trades Per Day", GroupName = "Risk", Order = 2)]
        public int MaxTradesPerDay { get; set; } = 8;

        [NinjaScriptProperty]
        [Display(Name = "Base Contracts", GroupName = "Risk", Order = 3)]
        public int BaseContracts { get; set; } = 8;

        // -----------------------------
        // USER PARAMETERS – SESSION
        // -----------------------------
        [NinjaScriptProperty]
        [Display(Name = "Use Time Window", GroupName = "Session", Order = 0)]
        public bool UseTimeWindow { get; set; } = true;

        [NinjaScriptProperty]
        [Display(Name = "Session Start (HHmmss)", GroupName = "Session", Order = 1)]
        public int SessionStart { get; set; } = 93000;

        [NinjaScriptProperty]
        [Display(Name = "Session End (HHmmss)", GroupName = "Session", Order = 2)]
        public int SessionEnd { get; set; } = 160000;

        // -----------------------------
        // INTERNAL STATE
        // -----------------------------
        private DateTime currentDay    = Core.Globals.MinDate;
        private int      tradesToday   = 0;
        private DateTime lastEntryTime = Core.Globals.MinDate;

        private double highWaterMark     = 0;   // global trailing high
        private bool   drawdownBreached  = false;
        private bool   tradeLimitHit     = false;

        // Prints
        private bool printedDrawdown  = false;
        private bool printedTradeMax  = false;
        private bool printedVixBrake  = false;

        // =======================================================
        //  STATE CHANGE
        // =======================================================
        protected override void OnStateChange()
        {
            if (State == State.SetDefaults)
            {
                Name = "M3_Fund";
                Description = "Model 3 Funded Edition — trailing DD, ATR stops, VIX brake.";

                Calculate = Calculate.OnEachTick;
                EntriesPerDirection = 1;
                EntryHandling = EntryHandling.AllEntries;

                IsExitOnSessionCloseStrategy = false;
                ExitOnSessionCloseSeconds = 0;
                TimeInForce = TimeInForce.Day;

                RealtimeErrorHandling = RealtimeErrorHandling.IgnoreAllErrors;
                ConnectionLossHandling = ConnectionLossHandling.KeepRunning;
                TraceOrders = true;
            }
            else if (State == State.Configure)
            {
                AddDataSeries("^VIX", BarsPeriodType.Minute, 1, MarketDataType.Last);
            }
            else if (State == State.DataLoaded)
            {
                fastEMA = EMA(9);
                slowEMA = EMA(21);
                rsi     = RSI(14, 3);
                atr     = ATR(14);

                AddChartIndicator(fastEMA);
                AddChartIndicator(slowEMA);
                AddChartIndicator(rsi);
                AddChartIndicator(atr);

                highWaterMark = GetEquitySafe(true);   // initialize with current equity
            }
        }

        // =======================================================
        //  MAIN BAR LOOP
        // =======================================================
        protected override void OnBarUpdate()
        {
            // Handle VIX updates
            if (BarsInProgress == 1)
            {
                vixLast = Closes[1][0];
                return;
            }

            if (BarsInProgress != 0)
                return;

            if (CurrentBar < 50)
                return;

            // Daily state (for trade counts/logs only)
            UpdateDailyState();

            // Session filter
            if (UseTimeWindow)
            {
                int t = ToTime(Time[0]);
                if (t < SessionStart || t > SessionEnd)
                    return;
            }

            // VIX crash brake
            if (UseVixCrashBrake && vixLast > VixPanicThreshold)
            {
                if (!printedVixBrake)
                {
                    Print(string.Format("[M3_Fund] VIX CRASH BRAKE — VIX={0:F2} > {1:F2}. Flatten & halt.",
                        vixLast, VixPanicThreshold));
                    printedVixBrake = true;
                }

                ExitOpenPositions();
                return;
            }

            // Trailing DD guards
            double currentEquity = GetEquitySafe(true);
            UpdateHighWaterMark(currentEquity);

            if (IsTradingHalted(currentEquity))
            {
                ExitOpenPositions();
                return;
            }

            // ===================================================
            //  ORIGINAL M3 SIGNAL ENGINE (NO RANDOMNESS)
            // ===================================================
            double mood = fastEMA[0] - slowEMA[0];

            double volBase = SMA(Volume, 20)[0];
            if (volBase <= 0)
                return;

            double volSpike = Volume[0] / volBase;

            bool goLong =
                (mood > 0.05) &&
                (rsi[0] > 45) &&
                (volSpike > 1.2);

            bool goShort =
                (mood < -0.05) &&
                (rsi[0] < 55) &&
                (volSpike > 1.2);

            if (Position.MarketPosition == MarketPosition.Flat)
            {
                if (tradesToday >= MaxTradesPerDay)
                    return;

                int stopTicks   = CalculateStopTicks();
                int targetTicks = CalculateTargetTicks();

                if (goLong)
                {
                    SetStopLoss("Amelia", CalculationMode.Ticks, stopTicks, false);
                    SetProfitTarget("Amelia", CalculationMode.Ticks, targetTicks);
                    EnterLong(BaseContracts, "Amelia");
                }
                else if (goShort)
                {
                    SetStopLoss("Amelia", CalculationMode.Ticks, stopTicks, false);
                    SetProfitTarget("Amelia", CalculationMode.Ticks, targetTicks);
                    EnterShort(BaseContracts, "Amelia");
                }
            }
            else
            {
                // Time stop
                if (lastEntryTime > Core.Globals.MinDate &&
                    (Time[0] - lastEntryTime).TotalSeconds >= TimeStopSeconds)
                {
                    if (Position.MarketPosition == MarketPosition.Long)
                        ExitLong("TimeStop", "Amelia");
                    else if (Position.MarketPosition == MarketPosition.Short)
                        ExitShort("TimeStop", "Amelia");
                }
            }
        }

        // =======================================================
        //  EXECUTION HANDLER
        // =======================================================
        protected override void OnExecutionUpdate(Execution execution, string executionId, double price, int quantity,
                                                  MarketPosition marketPosition, string orderId, DateTime time)
        {
            if (execution == null || execution.Order == null)
                return;

            if (execution.Order.OrderState != OrderState.Filled)
                return;

            if (execution.Order.Name == "Amelia" &&
                (execution.Order.OrderAction == OrderAction.Buy ||
                 execution.Order.OrderAction == OrderAction.SellShort))
            {
                tradesToday++;
                lastEntryTime = time;

                Print(string.Format("[M3_Fund] Trade count updated: {0}", tradesToday));
            }

            if (Position.MarketPosition == MarketPosition.Flat)
                lastEntryTime = Core.Globals.MinDate;
        }

        // =======================================================
        //  DAILY STATE (trade counts only)
        // =======================================================
        private void UpdateDailyState()
        {
            DateTime barDate = Times[0][0].Date;

            if (currentDay != barDate)
            {
                currentDay   = barDate;
                tradesToday  = 0;
                printedTradeMax = false;

                Print(string.Format("[M3_Fund] DAY RESET {0:yyyy-MM-dd}", currentDay));
            }
        }

        // =======================================================
        //  TRAILING DRAWDOWN & GUARDS
        // =======================================================
        private void UpdateHighWaterMark(double currentEquity)
        {
            if (currentEquity > highWaterMark)
            {
                highWaterMark = currentEquity;
                Print(string.Format("[M3_Fund] HWM UPDATE: {0:F2}", highWaterMark));
            }
        }

        private bool IsTradingHalted(double currentEquity)
        {
            // Trailing drawdown
            if (!drawdownBreached && currentEquity < highWaterMark - TrailingDrawdownLimit)
            {
                drawdownBreached = true;
                if (!printedDrawdown)
                {
                    Print(string.Format("[M3_Fund] GUARD: Trailing DD breached. Equity={0:F2}, HWM={1:F2}, Limit={2:F2}.",
                        currentEquity, highWaterMark, TrailingDrawdownLimit));
                    printedDrawdown = true;
                }
            }

            // Trade count cap
            if (!tradeLimitHit && tradesToday >= MaxTradesPerDay)
            {
                tradeLimitHit = true;
                if (!printedTradeMax)
                {
                    Print(string.Format("[M3_Fund] GUARD: Max trades per day reached ({0}/{1}).",
                        tradesToday, MaxTradesPerDay));
                    printedTradeMax = true;
                }
            }

            return drawdownBreached || tradeLimitHit;
        }

        private void ExitOpenPositions()
        {
            try { ExitLong("DD_Breach", "Amelia"); }  catch { }
            try { ExitShort("DD_Breach", "Amelia"); } catch { }
        }

        // =======================================================
        //  DYNAMIC STOP/TARGET (ATR)
        // =======================================================
        private int CalculateStopTicks()
        {
            if (!UseATR)
                return MinStopTicks;

            double atrValue = atr[0];
            int ticks = (int)(Math.Max((atrValue * StopATRMultiplier) / TickSize, MinStopTicks));
            return ticks;
        }

        private int CalculateTargetTicks()
        {
            if (!UseATR)
                return MinTargetTicks;

            double atrValue = atr[0];
            int ticks = (int)(Math.Max((atrValue * TargetATRMultiplier) / TickSize, MinTargetTicks));
            return ticks;
        }

        // =======================================================
        //  EQUITY HELPER (cash + realized + optional unrealized)
        // =======================================================
        private double GetEquitySafe(bool includeUnrealized)
        {
            double equity = AccountSize;

            try
            {
                if (Account != null)
                {
                    double cash = Account.Get(AccountItem.CashValue, Currency.UsDollar);
                    if (!double.IsNaN(cash) && !double.IsInfinity(cash) && cash > 0)
                        equity = cash;
                }
            }
            catch
            {
                // ignore – use fallback
            }

            double realized = SystemPerformance.AllTrades.TradesPerformance.Currency.CumProfit;
            equity += realized;

            if (includeUnrealized)
            {
                try
                {
                    double unreal = Position.GetUnrealizedProfitLoss(PerformanceUnit.Currency);
                    if (!double.IsNaN(unreal) && !double.IsInfinity(unreal))
                        equity += unreal;
                }
                catch
                {
                    // ignore
                }
            }

            return equity;
        }
    }
}
